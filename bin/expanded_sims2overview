#!/usr/bin/env perl

use strict;
use warnings;

use Data::Dumper;
use Getopt::Long;
use List::Util qw(first max min sum);

my $verbose  = 0;
my $abun_file= '';
my $in_file  = '';
my $out_file = '';
my $md5_file = '';
my $cluster  = '';
my $select   = '';
my $options  = { md5      => 1,
		 ontology => 1,
		 function => 1,
		 organism => 1,
		 source   => 1,
		 lca      => 1
	       };

if ( (@ARGV > 0) && ($ARGV[0] =~ /-h/) ) { &usage(); }
if ( ! GetOptions( "verbose!"           => \$verbose,
                   "abundance_file=s"	=> \$abun_file,
		   "expanded_sims_in=s" => \$in_file,
		   "summary_sims_out=s" => \$out_file,
		   "md5_index:s"        => \$md5_file,
		   "cluster:s"          => \$cluster,
		   "option=s"           => \$select
		 ) )
  { print &usage(); }

unless ($in_file && $out_file && (-s $in_file)) {
  &usage("No file $in_file.\n");
}
unless (exists $options->{$select}) {
  &usage("Unknown option $select.\n");
}
unless (!$abun_file || ($abun_file && (-s $abun_file))) {
  &usage("Abundance file: $abun_file is missing or empty and this is an assembled dataset.\n");
}

my $data  = {};
my $amap  = {};
my $cmap  = {};
my $imap  = {};
my $curr  = '';
my $curr2 = '';
my $count = 0;
my @thresholds_eval  = ( -5 , -10 , -20 , -30 , -1000 );
my @thresholds_len   = ( 10 , 25 , 50 , 100 , 1000000 );
my @thresholds_ident = ( 60 , 80 , 90 , 97 , 100 );

# get hash of abundance mapping file if $abun_file exists
if ($abun_file) {
  print STDOUT "Reading file $abun_file ... " if ($verbose);
  open(ABUN, "<$abun_file") || die "Can't open file $abun_file!\n";
  while(my $line = <ABUN>) {
    chomp $line;
    my @tabs = split(/\t/, $line);
    $amap->{$tabs[0]} = $tabs[1];
  }
  close ABUN;
  print STDOUT "Done\n" if ($verbose);
}

# get hash of cluster mapping file: cluster_id{seq_id} => 1
if ($cluster && (-s $cluster)) {
  print STDOUT "Reading file $cluster ... " if ($verbose);
  open(CLUST, "<$cluster") || die "Can't open file $cluster!\n";
  while (my $line = <CLUST>) {
    chomp $line;
    my @tabs = split(/\t/, $line);
    foreach my $seqid ($tabs[1], split(/,/, $tabs[2])) {
      push @{$cmap->{$tabs[0]}}, $seqid;
    }
  }
  close CLUST;
  print STDOUT "Done\n" if ($verbose);
}

# get hash of md5 index: md5 => [ seek, length ]
if (($select eq "md5") && $md5_file && (-s $md5_file)) {
  print STDOUT "Reading file $md5_file ... " if ($verbose);
  open(INDEX, "<$md5_file") || die "Can't open file $md5_file!\n";
  while (my $line = <INDEX>) {
    chomp $line;
    my ($m, $s, $l) = split(/\t/, $line);
    $imap->{$m} = [$s, $l];
  }
  close INDEX;
  print STDOUT "Done\n" if ($verbose);
}

print STDOUT "Parsing file $in_file ... " if ($verbose);
open(INFILE, "<$in_file") || die "Can't open file $in_file!\n";
open(OUTFILE, ">$out_file") || die "Can't open file $out_file!\n";

while (my $line = <INFILE>) {
  chomp $line;
  my ($md5, $frag, $ident, $len, $eval, $func, $org, $source, $taxid, @rest) = split(/\t/, $line);
  unless ($frag and $md5) { next; }

  if ($select eq "md5") {
    if ($curr eq '') { $curr = $md5; }
    if ($curr ne $md5) {
      print OUTFILE &get_md5_stats($imap, $cmap, $data, $curr);
      $data = {};
      $curr = $md5;
      $count++;
    }
    $data->{eval}{$eval}   += 1;
    $data->{len}{$len}     += 1;
    $data->{ident}{$ident} += 1;
    $data->{frag}{$frag}    = 1;
  }
  elsif ($select eq 'lca') {
    unless ($func) { next; }
    if ($curr eq '') { $curr = $func; }
    if ($curr ne $func) {
      print OUTFILE &get_lca_stats($cmap, $data, $curr, $curr2);
      $data  = {};
      $curr  = $func;
      $curr2 = $org;
      $count++;
    }
    map { $data->{eval}{$_}  += 1 } split(/;/, $eval);
    map { $data->{len}{$_}   += 1 } split(/;/, $len);
    map { $data->{ident}{$_} += 1 } split(/;/, $ident);
    map { $data->{md5}{$_}   += 1 } split(/;/, $md5);
    $data->{frag}{$frag} = 1;
  }
  elsif ($select eq "function") {
    unless ($func) { next; }
    if ($curr eq '') { $curr = $func; }
    if ($curr ne $func) {
      print OUTFILE &get_type_stats($cmap, $data, $select, $curr);
      $data = {};
      $curr = $func;
      $count++;
    }
    $data->{$source}{eval}{$eval}   += 1;
    $data->{$source}{len}{$len}     += 1;
    $data->{$source}{ident}{$ident} += 1;
    $data->{$source}{md5}{$md5}     += 1;
    $data->{$source}{frag}{$frag}    = 1;
  }
  elsif ($select eq "organism") {
    unless ($org) { next; }
    if ($curr eq '') { $curr = $org; }
    if ($curr ne $org) {
      print OUTFILE &get_type_stats($cmap, $data, $select, $curr, $curr2);
      $data  = {};
      $curr  = $org;
      $curr2 = $taxid || '';
      $count++;
    }
    $data->{$source}{eval}{$eval}   += 1;
    $data->{$source}{len}{$len}     += 1;
    $data->{$source}{ident}{$ident} += 1;
    $data->{$source}{md5}{$md5}     += 1;
    $data->{$source}{frag}{$frag}    = 1;
  }
  elsif ($select eq "ontology") {
    unless ($org) { next; }
    if ($curr eq '') { $curr = $org; }
    if ($curr ne $org) {
      print OUTFILE &get_type_stats($cmap, $data, $select, $curr, $curr2);
      $data  = {};
      $curr  = $org;
      $curr2 = $func;
      $count++;
    }
    $data->{$source}{eval}{$eval}   += 1;
    $data->{$source}{len}{$len}     += 1;
    $data->{$source}{ident}{$ident} += 1;
    $data->{$source}{md5}{$md5}     += 1;
    $data->{$source}{frag}{$frag}    = 1;
  }
  elsif ($select eq "source") {
    unless ($source) { next; }
    if ($curr eq '') { $curr = $source; }
    if ($curr ne $source) {
      print OUTFILE &get_source_stats($data, $curr);
      $data = {};
      $curr = $source;
      $count++;
    }
    my $exp = &get_exponent($eval);
    $data->{eval}{$exp}    += 1;
    $data->{ident}{$ident} += 1;
  }
}
close(INFILE);

if ($select eq "md5") {
  print OUTFILE &get_md5_stats($imap, $cmap, $data, $curr);
}
elsif ($select eq 'lca') {
  print OUTFILE &get_lca_stats($cmap, $data, $curr, $curr2);
}
elsif (($select eq "function") || ($select eq "organism") || ($select eq "ontology")) {
  print OUTFILE &get_type_stats($cmap, $data, $select, $curr, $curr2);
}
elsif ($select eq "source") {
  print OUTFILE &get_source_stats($data, $curr);
}
close(OUTFILE);

print STDOUT "Done - $count ${select}s parsed\n" if ($verbose);
exit 0;

sub get_md5_stats {
  my ($imap, $cmap, $data, $md5) = @_;
  
  unless ($md5 && (scalar(keys %{$data->{frag}}) > 0)) { return ''; }

  my $f_num = 0;
  my $exps  = {};
  my @evals = keys %{$data->{eval}};

  foreach my $frag (keys %{$data->{frag}}) {
    if(exists $cmap->{$frag}) {
      foreach my $cluster_frag (@{$cmap->{$frag}}) {
        $cluster_frag =~ s/^(.*)\_\d+\_\d+\_[+-]/$1/;
        if(exists $amap->{$cluster_frag}) {
          $f_num += $amap->{$cluster_frag};
        } else {
          $f_num += 1;
        }
      }
    } else {
      $frag =~ s/^(.*)\_\d+\_\d+\_[+-]/$1/;
      if(exists $amap->{$frag}) {
        $f_num += $amap->{$frag};
      } else {
        $f_num += 1;
      }
    }
  }

  map { $exps->{ &get_exponent($_) } += $data->{eval}{$_} } @evals;

  my ($e_min, $e_max, $e_mean, $e_std) = &get_stats($exps);
  my ($l_min, $l_max, $l_mean, $l_std) = &get_stats($data->{len});
  my ($i_min, $i_max, $i_mean, $i_std) = &get_stats($data->{ident});

  $e_min = min @evals;
  $e_max = max @evals;

  my ($seek, $len) = exists($imap->{$md5}) ? @{$imap->{$md5}} : ('', '');
  
  #output
  return join("\t", ( $md5, int($f_num),
		      $e_min, $e_max, $e_mean, $e_std,
		      &to_count_array($exps, "eval"),
		      $l_min, $l_max, $l_mean, $l_std,
		      &to_count_array($data->{len}, "len"),
		      $i_min, $i_max, $i_mean, $i_std,
		      &to_count_array($data->{ident}, "ident"),
		      $seek, $len
		    ) ) . "\n";
}

sub get_lca_stats {
  my ($cmap, $data, $lca, $level) = @_;

  unless ($lca && (scalar(keys %{$data->{frag}}) > 0)) { return ''; }

  my $f_num = 0;
  my $exps  = {};
  my @evals = keys %{$data->{eval}};

  foreach my $frag (keys %{$data->{frag}}) {
    if(exists $cmap->{$frag}) {
      foreach my $cluster_frag (@{$cmap->{$frag}}) {
        $cluster_frag =~ s/^(.*)\_\d+\_\d+\_[+-]/$1/;
        if(exists $amap->{$cluster_frag}) {
          $f_num += $amap->{$cluster_frag};
        } else {
          $f_num += 1;
        }
      }
    } else {
      $frag =~ s/^(.*)\_\d+\_\d+\_[+-]/$1/;
      if(exists $amap->{$frag}) {
        $f_num += $amap->{$frag};
      } else {
        $f_num += 1;
      }
    }
  }

  map { $exps->{ &get_exponent($_) } += $data->{eval}{$_} } @evals;

  my ($e_min, $e_max, $e_mean, $e_std) = &get_stats($exps);
  my ($l_min, $l_max, $l_mean, $l_std) = &get_stats($data->{len});
  my ($i_min, $i_max, $i_mean, $i_std) = &get_stats($data->{ident});

  $e_min = min @evals;
  $e_max = max @evals;

  #output
  return join("\t", ( $lca, int($f_num),
		      $e_min, $e_max, $e_mean, $e_std,
		      &to_count_array($exps, "eval"),
		      $l_min, $l_max, $l_mean, $l_std,
		      &to_count_array($data->{len}, "len"),
		      $i_min, $i_max, $i_mean, $i_std,
		      &to_count_array($data->{ident}, "ident"),
		      scalar(keys %{$data->{md5}}),
		      $level
		    ) ) . "\n";
}

sub get_type_stats {
  my ($cmap, $data, $select, $name, $extra) = @_;
  
  unless ($name && (scalar(keys %$data) > 0)) { return ''; }

  my $text = '';
  foreach my $src (keys %$data) {
    unless (scalar(keys %{$data->{$src}{frag}}) > 0) { next; }

    my $f_num = 0;
    my $exps  = {};
    my @evals = keys %{$data->{$src}{eval}};

    foreach my $frag (keys %{$data->{$src}{frag}}) {
      if(exists $cmap->{$frag}) {
        foreach my $cluster_frag (@{$cmap->{$frag}}) {
          $cluster_frag =~ s/^(.*)\_\d+\_\d+\_[+-]/$1/;
          if(exists $amap->{$cluster_frag}) {
            $f_num += $amap->{$cluster_frag};
          } else {
            $f_num += 1;
          }
        }
      } else {
        $frag =~ s/^(.*)\_\d+\_\d+\_[+-]/$1/;
        if(exists $amap->{$frag}) {
          $f_num += $amap->{$frag};
        } else {
          $f_num += 1;
        }
      }
    }

    map { $exps->{ &get_exponent($_) } += $data->{$src}{eval}{$_} } @evals;

    my ($e_min, $e_max, $e_mean, $e_std) = &get_stats($exps);
    my ($l_min, $l_max, $l_mean, $l_std) = &get_stats($data->{$src}{len});
    my ($i_min, $i_max, $i_mean, $i_std) = &get_stats($data->{$src}{ident});
    
    $e_min = min @evals;
    $e_max = max @evals;

    # output
    $text .= join("\t", ( $name, int($f_num),
			  $e_min, $e_max, $e_mean, $e_std,
			  &to_count_array($exps, "eval"),
			  $l_min, $l_max, $l_mean, $l_std,
			  &to_count_array($data->{$src}{len}, "len"),
			  $i_min, $i_max, $i_mean, $i_std,
			  &to_count_array($data->{$src}{ident}, "ident"),
			  "{" . join(",", keys %{$data->{$src}{md5}}) . "}",
			  $src ));
    $text .= (($select eq "organism") || ($select eq "ontology")) ? "\t$extra\n" : "\n";
  }
  return $text;
}

sub get_source_stats {
  my ($data, $source) = @_;

  unless ($source) { return ''; }
  my $e_nums = &to_count_array($data->{eval}, "eval", 1);
  my $i_nums = &to_count_array($data->{ident}, "ident", 1);

  return "$source\t" . join("\t", @$e_nums) . "\t" . join("\t", @$i_nums) . "\n";
}

sub get_exponent {
  my ($eval) = @_;

  my ($m, $e) = split(/e/, $eval);
  unless ($e) {
    my ($tmp) = $eval =~ /0\.(\d+)$/;
    my @count = $tmp =~/(\d)/gc;
    $e = scalar @count;
    $e = $e * -1;
  }
  return $e * 1;
}

# return (min, max, mean, stdev)
sub get_stats {
  my ($data) = @_;

  my @uniq  = keys %$data;
  my $count = sum values %$data;
  my $min   = min @uniq;
  my $max   = max @uniq;
  my $total = 0;
  map { $total += ($_ * $data->{$_}) } @uniq;

  my $mean = $total / $count;
  my $sum  = 0;

  foreach my $d (@uniq) {
    for (my $i = 0; $i < $data->{$d}; $i++) {
      my $dev = $d - $mean;
      $sum += ($dev * $dev);
    }
  }
  $mean     = sprintf( "%.3f", $mean );
  my $stdev = sprintf( "%.3f", sqrt($sum / $count) );

  return ($min, $max, $mean, $stdev);
}

sub to_count_array {
  my ($data, $type, $array) = @_;

  my @bin = (0, 0, 0, 0, 0);
  if ($type eq 'eval') {
    my $zero = 0;
    foreach my $exp (sort {$b <=> $a} keys %$data) {
      if ($exp == 0) {
	$zero += $data->{$exp};
	next;
      }
      for (my $i = 0; $i < @thresholds_eval; $i++) {
	if ($exp >= $thresholds_eval[$i]) {
	  $bin[$i] += $data->{$exp};
	  last;
	}
      }
    }
    $bin[-1] += $zero;
  }
  elsif ($type eq 'len') {
    foreach my $len (sort {$a <=> $b} keys %$data) {
      for (my $i = 0; $i < @thresholds_len; $i++) {
	if ($len <= $thresholds_len[$i]) {
	  $bin[$i] += $data->{$len};
	  last;
	}
      }
    }
  }
  elsif ($type eq 'ident') {
    foreach my $ident (sort {$a <=> $b} keys %$data) {
      for (my $i = 0; $i < @thresholds_ident; $i++) {
	if ($ident <= $thresholds_ident[$i]) {
	  $bin[$i] += $data->{$ident};
	  last;
	}
      }
    }
  }
  return $array ? \@bin : "{".join(",", @bin)."}";
}

sub usage {
  my ($message) = @_;

  my $opt_str = join(" | ", sort keys %$options);
  print STDERR qq($0
Create summary statistics file from expanded sims file, for loading into ACH.

expanded: md5, fragment, identity, length, evalue, function, organism, source, tax_id
ontology: md5, fragment, identity, length, evalue, function, id, source
LCA:      md5 list, fragment, identity list, length list, evalue list, lca string, depth of lca (1-8)
summary: md5|function|organism|ontology|lca, abundance,
         eval min, eval max, avg eval, stdev eval, eval list,
         len min, len max, avg len, stdev len, len list,
         ident min, ident max, avg ident, stdev ident, ident list,
         fragment|md5 list, [source, tax_id|annotation]

  --expanded_sims_in  file name    Required. Name of input expanded sim file
  --summary_sims_out  file name    Required. Name of output summary sim file.
  --md5_index         file name    Optional. md5 \\t seek \\t length
  --cluster           file name    Optional. If queries are cluster names, will increase abundance count based on cluster size.
  --option            option type  Required. Sorted input format and output type.
                                             $opt_str
  --verbose                        Optional. Verbose output.

);
  print STDERR "$message\n" if ($message);
  exit 1;
}
